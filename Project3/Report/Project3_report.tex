\documentclass[12pt, a4paper]{article}
\usepackage[print,sort]{standalone}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{graphicx,float}
\usepackage{amssymb}
\usepackage{amsmath,cancel}
\usepackage{mathrsfs}
\usepackage{epstopdf}
\usepackage{subcaption}
\usepackage{slashed}
\usepackage{hhline}
\usepackage[margin=1.2in]{geometry}
\usepackage[hidelinks]{hyperref}
\usepackage{wrapfig}


\hfuzz=5pt


\begin{document}

\begin{titlepage}
\begin{center}
\vspace*{3cm}
\Huge
\textbf{Project 3} \\
\Large  
FYS4150 Computational Physics 
\vspace*{3cm} \\ 

Even S. HÃ¥land 
\vspace*{5cm} \\

\normalsize
\section*{Abstract}

The motion of the planets in the solar system is governed by gravitational forces between the planets 
and the sun, and between the planets themselves. This can be expressed mathematically as a set of coupled 
differential equation. In this project we solve these equations, mainly by using the velocity Verlet 
algorithm. When doing so we use an object oriented approach, and two classes are developed; a 
\textit{planet} class and a \textit{solver} class. We find that the problem can be solved in a quite nice 
and compact way, and we get quite good estimates of the planetary orbits.  

\end{center}
\end{titlepage}

\section{Introduction}

\section{Modelling planetary motion}

Newtons law of gravitation states that the gravitational force between two objects, with mass $M$ and $m$
respectively, is given by 
\begin{align}
F_G = \frac{GMm}{r^2}, 
\end{align}
where $G$ is the gravitational constant and $r$ is the distance between the two objects. 

\subsection*{Earth-Sun system}

We start by considering a system with only two objects, namely the Sun (with mass $M_{\odot}$) and the 
Earth (with mass $M_{\text{ Earth}}$), and we assume that the Sun is fixed, so the only motion we have to
care about is that of the Earth. We also assume that the motion of the Earth is co-planar, and take this 
to be the $xy$-plane, with the Sun in the origin. When writing the programs and implementing the 
algorithm we actually work in $3D$, but extending from two to three dimensions is quite trivial.  

The forces acting on the Earth in the $x$- and $y$-direction are then given by 
\begin{align*}
F_{G,x} = - F_G \cos\theta  = - \frac{GM_{\odot} M_{\text{Earth}}}{r^2}\cos\theta 
							= - \frac{GM_{\odot} M_{\text{Earth}}}{r^3}x 
\end{align*} 
and 
\begin{align*}
F_{G,y} = - F_G \sin\theta  = - \frac{GM_{\odot} M_{\text{Earth}}}{r^2}\sin\theta 
							= - \frac{GM_{\odot} M_{\text{Earth}}}{r^3}y,  
\end{align*}
where we have used the relations $x = r\cos\theta$ and $y = r\sin\theta$. From Newtons second law we know 
that the accelerations, $a_x$ and $a_y$, are given as 
\begin{align*}
a_x = \frac{d^2x}{dt^2} = \frac{F_{G,x}}{M_{\text{Earth}}} \quad \text{and} \quad 
a_y = \frac{d^2y}{dt^2} = \frac{F_{G,y}}{M_{\text{Earth}}}. 
\end{align*} 
We also know that the acceleration is the time derivative of the velocity, $v$, which again is 
the time derivative of the position, meaning that we can express the equations of motion as two 
coupled first order differential equations in each dimension:  
\begin{align}
v_x = \frac{dx}{dt}, \quad v_y = \frac{dy}{dt}, \quad 
a_x = \frac{dv_x}{dt} = -\frac{GM_{\odot}x}{r^3}, \quad a_y = \frac{dv_y}{dt} = -\frac{GM_{\odot}y}{r^3}.   
\label{eq:diff_eqs}
\end{align}
When extending to three dimensions we simply add two more equations like those above, simply 
replacing $x$ or $y$ by $z$. 

\subsection*{Scaling of equations}

The next thing we want to do is to scale the equations appropriately. When working on an astronomical 
scale we prefer to work with years (yr) as the time unit and AU\footnote{Astronomical units; $1$ AU is
defined as the mean distance between the Earth and the Sun.} as the length unit. This means that we 
need to find some way of scaling the gravitational constant, $G$, to these units. 

If we assume the orbit 
of the Earth to be circular (which is very close to the truth), the acceleration is given as 
\begin{align*}
a = \frac{v^2}{r} = \frac{F_G}{M_{\text{Earth}}} = \frac{GM_{\odot}}{r^2} \quad \Rightarrow \quad 
v^2 r = GM_{\odot}. 
\end{align*}  
where $r = 1$ AU, while the velocity is 
\begin{align*}
v = 2\pi \:\: \text{AU/yr},   
\end{align*}
which means that 
\begin{align*}
GM_{\odot} = 4\pi^2 \:\: \text{AU}^3/\text{yr}^2,  
\end{align*}
which can be inserted in the equations of motion. In addition to this it is also 
convenient to scale the mass of the earth (and other planets) to the solar mass, i.e. we put 
$M_{\odot} = 1$, and scale other masses accordingly. We do this to decrease the chance of loosing 
numerical precision through round-off errors, as the planetary masses are quite large (see Table  
\ref{tab:planets}). 

\subsection*{The solar system}

Once we know the form of the gravitational interaction it is quite easy to extend our system to include 
other planets, and eventually the full solar system. The general forces in the $xy$-planet  
between two planets with mass $M_a$ and $M_b$ are given by 
\begin{align*}
F_{G,x} = \frac{GM_aM_b}{r^3}\Delta x \quad \text{and} \quad F_{G,y} = \frac{GM_aM_b}{r^3}\Delta y, 
\end{align*}  
where $\Delta x$ and $\Delta y$ are the distances between the planets in $x$- and $y$-direction, and 
$r$ the absolute distance between them. When we want to model a system with several planets we simply 
add up the forces acting on each planet, and calculate the acceleration of a specific planet as 
the total force acting on it divided by its mass. The planets of the solar system are listed in Table 
\ref{tab:planets}, along with their masses and distances to the Sun.   

\begin{table}
\caption{Mass and distance to the Sun for the planets in the solar system. (Numbers taken from the 
project description.)}
\label{tab:planets}
\begin{center}
\begin{tabular}{ccc} \hline\hline
Planet & Mass (kg) & Distance to Sun (AU) \\ \hline 
Earth & $6\times10^{24}$ & $1$  \\
Jupiter & $1.9\times10^{27}$ & $5.20$  \\
Mars & $6.6\times10^{23}$ & $1.52$ \\
Venus & $4.9\times10^{24}$ & $0.72$ \\
Saturn & $5.5\times10^{26}$ & $9.54$ \\ 
Mercury & $3.3\times10^{23}$ & $0.39$ \\ 
Uranus & $8.8\times10^{25}$ & $19.19$ \\ 
Neptune & $1.03\times10^{26}$ & $30.06$  \\ 
Pluto & $1.31\times10^{22}$ & $39.53$ \\ \hline \hline
\end{tabular}
\end{center}
\end{table}

Before we start looking at how we should study this numerically there is one more thing that needs to 
be mentioned in this somewhat theoretical introduction. Although Newtonian mechanics is able to describe 
the planetary orbits quite well, it does not provide a perfect approximation. This is most evident when 
observing the perihelion precession of Mercury, which is found to be off by $43''$ ($\sim 0.012^{\circ}$)
per century (which is a very small deviation!) compared to the predictions from the Newtonian theory.
However, in Einstein's general theory of relativity the gravitational force gets a small correction, 
and can be written as 
\begin{align*}
F_G = \frac{GM_{\odot}M_{\text{Mercury}}}{r^2}\left[ 1+ \frac{3l^2}{r^2c^2} \right], 
\end{align*} 
where $l=|\mathbf{r}\times \mathbf{v}|$ is the magnitude of the orbital angular momentum of Mercury and 
$c$ is the speed of light. Towards the end of the project we will see (spoiler alert!) that this 
correction actually is able to explain the observed perihelion precession of Mercury!  

\section{Discretization and algorithms}

The main objective is to write a code that calculate updated positions for system of planets as time 
passes. In order to do so we must, as usual, start by making a discrete approach to the problem. 
The discretization will only be shown for one dimension ($x$), since the procedure is completely
equivalent for the other dimensions. Time and position are discretized as 
\begin{align*}
&t  \rightarrow t_i = t_0 + ih \\
&x(t)  \rightarrow x(t_i) = x_i, 
\end{align*}   
with the time step, $h$, given by 
\begin{align*}
h = \frac{t_f - t_0}{n}.  
\end{align*}
Here $t_0$ and $t_f$ is the initial and final time respectively, $n$ is total number of time steps and 
$i$ runs from $1$ to $n$. 

Position and velocity after some time $t_i+h$ is given by Taylor expansion as 
\begin{align}
x_{i+1} & = x_i + hx_i' + \frac{h^2}{2}x_i'' + O(h^3) \\ 
	    & = x_i + hv_i + \frac{h^2}{2}a_i + O(h^3)
\label{eq:Taylor_pos}	    
\end{align}
and 
\begin{align}
v_{i+1} & = v_i + hv_i' + \frac{h^2}{2}v_i'' + O(h^3) \\
		& = v_i + ha_i + \frac{h^2}{2}v_i'' + O(h^3),  
\label{eq:Taylor_vel}
\end{align}
where $a_i$ is the acceleration, which for the Earth-Sun system is given in discrete form as  
\begin{align*}
a_i = \frac{F(x_i,t_i)}{M_{\text{Earth}}} = - \frac{GM_{\odot}x_i}{r_i^3}. 
\end{align*}
Based on these equations we will consider two methods for approximating positions and velocities.

The first one is the forward Euler method, which we get directly from the above equations, by only 
including terms from eqs. (\ref{eq:Taylor_pos}) and (\ref{eq:Taylor_vel}) up to $O(h^2)$: 
\begin{align*}
x_{i+1} & \approx x_i + hv_i \\ 
v_{i+1} & \approx v_i + ha_i 
\end{align*}

The second one is the velocity Verlet method, where we keep terms up to $O(h^3)$. This means that we are 
stuck with a second derivative of the velocity, which we want to get rid of. This is done by 
Eulers formula, so 
\begin{align*}
v_i'' \approx \frac{v_{i+1}'+v_i'}{h} = \frac{a_{i+1}'+a_i'}{h},  
\end{align*}
which leaves us with the following approximations for position and velocity: 
\begin{align*}
x_{i+1} & \approx x_i + hv_i + \frac{h^2}{2}a_i  \\
v_{i+1} & \approx v_i + \frac{h}{2}\left[ a_{i+1} + a_i  \right] 
\end{align*}

Both of these methods will be implemented in our code. However, velocity Verlet will be 
proven to work somewhat better than forward Euler, so throughout most of the project we 
will stick to using the velocity Verlet method. 

Notice that in order to get the algorithms started we need some initial values for position and velocity,
i.e. $x_0$ and $v_0$, hence these kinds of problems are referred to as \textit{initial value problems}.   

\section{Code}

All code written for this project can be found in the following git repository: \vspace{0.5cm} \\ 
\fbox{
\href{https://github.com/evensha/FYS4150/tree/master/Project3/Programs}
{https://github.com/evensha/FYS4150/tree/master/Project3/Programs} } \vspace{0.5cm} \\ 
The most important files in this repository are:  
\begin{itemize}
\item \texttt{planet.cpp/planet.h}
\item \texttt{solver.cpp/solver.h}
\item \texttt{main.cpp}
\item \texttt{Plot\_planets.py}
\end{itemize}
Before going into the details of the code we should have a quick look at the main structure and purpose 
of the different programs and classes. 

Firstly we have two classes called \textbf{planet} (implemented in \texttt{planet.cpp} and 
\texttt{planet.h}) and \textbf{solver} (implemented in \texttt{solver.cpp} and \texttt{solver.h}). 
The main idea is that we let each planet we want to consider be an object of the planet class, 
which has properties like position, velocity, mass, and functions that can calculate other quantities 
for the planet. We then make an object of the solver class, and put our planets in to this object. 
The solver class contain functions that will solve our problem, i.e. by using forward Euler or 
velocity Verlet, in addition to other functions that could be useful. The main program (\texttt{main.cpp}) 
is used to initialize the necessary objects, and run the solver functions, while the python script 
\texttt{Plot\_planets.py} is used for plotting the results. The output from the programs is stored in 
the "Output" repository. However, one might not find all produced output files in the mentioned git 
repository, as some of the produced output files are quite big.  

In addition to the above described programs it is also worth mentioning that the git repository contains 
a \texttt{makefile}, used for compiling it all, and a file called \texttt{Planet\_data.txt}. The latter 
file contains necessary information about all the planets, i.e. mass and the positions and velocities 
we will use as initial values. 

\subsection{The planet class}

The planet class has four public variables: 
\begin{itemize}
\item \texttt{mass} (double)  
\item \texttt{position} (double, 3D vector)
\item \texttt{velocity} (double, 3D vector) 
\item \texttt{name} (string) 
\end{itemize}
An object of this class can be initialized with a default initialization that sets all the variables to 
zero, and the name to "Planet". Alternatively it can be initialized with mass, positions, velocities and 
name. Positions and velocities can be given in either two or three dimension. 

Further the class contains the following functions (which all return a double): 
\begin{itemize}
\item \texttt{Distance(planet otherPlanet):} Take an other object of the planet class as input argument, 
and calculates the distance to this planet. 
\item \texttt{PotentialEnergy(double Gconst):} Take an other object of the planet class as input, and 
calculates the planets potential energy with respect to the other planet.   
\item \texttt{xMomentum():} Calculates the planets momentum in the $x$-direction. 
\item \texttt{yMomentum():} Calculates the planets momentum in the $y$-direction. 
\item \texttt{AngularMomentum():} Calculates the magnitude of the orbital angular momentum per unit 
mass of the planet. 
\end{itemize}

\subsection{The solver class}

\subsection{The main program and plotting}

\subsection{Testing the code}

\section{Results}

\section{Summary and conclusions}

\end{document}

